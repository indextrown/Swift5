/*
 
 (185강)
 프로토콜에서의 제네릭
 - 메서드를 정의할 때 타입을 미리 정의해놓지 않는 것이다
 - 채택하는 타입에서 타입에 대한 정의를 구체적으로 한다음 사용가능하다
 - 프로토콜 자체도 유연성이 넓어진다
 
 프로토콜을 제네릭 타입으로 선언하려면
 - 연관타입으로 선언해야함
 
 타입이 구체화되지 않은 메서드들은 반드시 채택한 실제 타입에서 구체적인 타입을 가지고 구현을 해줘야 한다
 
 */

// 프로토콜에서도 제네릭 사용 가능

// MARK: 프로토콜 정의
protocol RemoteControl {
    // MARK: 프로토콜에서 선언한 연관타입 애플에서는 T보다 관습적으로 element 사용하긴한다
    associatedtype T // 프로토콜에서는 <T> 대신 사용함 // 힌트를 주는 역할
    func changeChannel(to: T)
    func alert() -> T?
}

/*
 MARK: 프로토콜은 클래스를 정의하거나 열거형 정의하거나 구조체 정의하는 데 자체가 타입이 아니다
 타입으로 동작은 하지만 타입에서 채택을 쓰지 않고는 자체로는 의미가 없다
 구체적인 타입은 tv or 에어컨
 구체적인 타입은 TV나 에어컨이고  프로토콜은 한단계 위에 존재하기 떄문에 채택을 해서 써야한다
 프로토콜 자체가 타입이 아니기 때문에 protocol RemoteControl<T>{}를 안쓰는거같다
 */

struct TV: RemoteControl {
    // MARK: 프로토콜에서 선언한 연관타입을 채택한곳에서는 명시적으로 어떤 타입으로 사용할지 언급 필요
    // MARK: 그 방법이 typealias 사용이다
    // Int를 T라는 이름에 할당했다 -> 이유: 프로토콜을 채택한 녀석에서 연관타입에 대한 구체적 타입을 명시해야 하기 때문
    typealias T = Int // MARK: 생략가능
    
    func changeChannel(to: Int) {
        print("TV 채널바꿈: \(to)")
    }
    
    func alert() -> Int? {
        return 1
    }
}
